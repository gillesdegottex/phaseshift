# Copyright (C) 2025 Gilles Degottex <gilles.degottex@gmail.com> All Rights Reserved.
#
# You may use, distribute and modify this code under the
# terms of the Apache 2.0 license.
# If you don't have a copy of this license, please visit:
#     https://github.com/gillesdegottex/phaseshift

import numpy as np
import scipy

import matplotlib.pyplot as plt
plt.ion()

def lin2db(x):
    return 20*np.log10(abs(x))


xs = np.arange(-10.1, 10.1, 0.01)

limit = 127.0/128  # 8-bit signed upper limit is 0.9921875
kneestart = 0.66

xs_table_vmax = 3.0

def softclipper01_groundtruth(xs):

    # Replace the transition band by the upper part of a sigmoid
    # xs = (2.0 / (1.0 + np.exp(-2*xs)) - 1)

    # 2D spline from points and slopes
    xi = np.array([0, xs_table_vmax])
    yi = np.array([[0, 1],[1, 0]])
    pp = scipy.interpolate.BPoly.from_derivatives(xi, yi, extrapolate=False)
    xs = pp(xs)

    return xs

def softclipper01_table_build(xs_table_vmax):

    xs_table_step = 0.005
    xs_table = np.arange(0.0, xs_table_vmax+xs_table_step, xs_table_step)
    ys_table = softclipper01_groundtruth(xs_table)
    ys_table[np.where(np.isnan(ys_table))[0]] = limit
    ys_table = np.array(ys_table, dtype=np.float32)

    np.savetxt("clipper.txt", ys_table)

    # plt.plot(xs_table, ys_table, 'g')

    lf = open("clipper_table.h", "w")
    lf.write(f"// Generated by clipper_table_gen.py\n")
    lf.write(f"float g_clipper_table_xmin = {0.0};\n")
    lf.write(f"float g_clipper_table_xmax = {xs_table[-1]};\n")
    lf.write(f"int g_clipper_table_size = {len(ys_table)};\n")
    lf.write(f"float g_clipper_table_step = {xs_table_step};\n")
    lf.write("const static float g_clipper_table[] = {")
    lf.write(", ".join([str(y) for y in ys_table]))
    lf.write("};\n")
    lf.close()

softclipper01_table_build(xs_table_vmax)
X = np.loadtxt("clipper.txt", dtype=np.float32)
print(f"softclipper01_table={len(X)}")

def softclipper01_table(xs):
    xs_comp = xs.copy()
    ys_comp = []
    for x in xs_comp:
        # idx = int(np.round(len(X)*x/xs_table_vmax))
        idx = int(0.5+len(X)*x/xs_table_vmax)
        if idx > len(X)-1:
            ys_comp.append(1.0)
        else:
            ys_comp.append(X[idx])

    ys_comp = np.array(ys_comp)

    return ys_comp

def softclipper(xs, softclipper01fn):
    # Needs:
    #    Do not alter below some threshold
    
    transition_band = limit - kneestart
    negidx = np.where( xs < 0.0)
    posidx = np.where( xs >= 0.0)
    xs = abs(xs)

    compidx = np.where( xs > kneestart )
    overidx = np.where( (xs-kneestart)/transition_band > xs_table_vmax )
    # overidx = np.where( xs > xs_table_vmax)

    xs[compidx] = kneestart + transition_band*softclipper01fn((xs[compidx]-kneestart)/transition_band)

    xs[overidx] = limit

    xs[negidx] *= -1.0
    return xs

if 0:
    ax1 = plt.subplot(211)
    plt.plot(xs, xs, ':k')
    plt.plot(xs, softclipper(xs, softclipper01_groundtruth), 'b')
    plt.plot(xs, softclipper(xs, softclipper01_table), 'r')
    # plt.plot(xs, softclipper_table(xs), 'r')
    plt.ylim([-1.1, +1.1])
    plt.grid()

    plt.subplot(212, sharex=ax1)
    xs_valid = np.arange(-10.1, 10.1, 0.001)
    errs = softclipper(xs_valid, softclipper01_groundtruth) - softclipper(xs_valid, softclipper01_table)
    plt.plot(xs_valid, errs, 'r')
    plt.grid()
    print(f"max(errs)={lin2db(max(abs(errs)))}")  # max(errs)=-78.4874554800404

    from IPython.core.debugger import  Pdb; Pdb().set_trace()
